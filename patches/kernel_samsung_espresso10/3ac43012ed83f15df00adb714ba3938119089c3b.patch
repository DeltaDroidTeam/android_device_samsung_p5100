From 3ac43012ed83f15df00adb714ba3938119089c3b Mon Sep 17 00:00:00 2001
From: Ketut Putu Kumajaya <kumajaya@samator.com>
Date: Fri, 8 Mar 2013 16:16:43 +0700
Subject: [PATCH] overclock: adapting cmenard's OMAP4430 overclock codes

---
 arch/arm/mach-omap2/Kconfig                  |  8 +++
 arch/arm/mach-omap2/board-espresso-irled.c   |  7 ++-
 arch/arm/mach-omap2/board-espresso10-irled.c |  7 ++-
 arch/arm/mach-omap2/control.h                |  1 +
 arch/arm/mach-omap2/dpll44xx.c               |  1 +
 arch/arm/mach-omap2/omap2plus-cpufreq.c      | 69 ++++++++++++++++++++++++
 arch/arm/mach-omap2/omap4_trim_quirks.c      |  8 +++
 arch/arm/mach-omap2/opp4xxx_data.c           | 80 ++++++++++++++++++++++++++++
 arch/arm/mach-omap2/smartreflex-class3.c     |  4 ++
 drivers/cpufreq/cpufreq.c                    |  6 +++
 10 files changed, 189 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index d8f0798..282ddac 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -459,6 +459,14 @@ config OMAP4_HSOTG_ED_CORRECTION
 	  Select this option to overrive HSOTG PHY settings in
 	  order to improve Eye Diagramm. On 4430 CPUs this should
 	  improve Eye Diagram at least 8%.
+config OMAP4430_CPU_OVERCLOCK
+	bool "Enables OMAP 4430 CPU overclock"
+	depends on ARCH_OMAP4
+	default n
+config OMAP4430_GPU_OVERCLOCK
+	bool "Enables OMAP 4430 GPU overclock"
+	depends on ARCH_OMAP4
+	default n
 endmenu
 
 endif
diff --git a/arch/arm/mach-omap2/board-espresso-irled.c b/arch/arm/mach-omap2/board-espresso-irled.c
index 7ab5319..b8854d5 100644
--- a/arch/arm/mach-omap2/board-espresso-irled.c
+++ b/arch/arm/mach-omap2/board-espresso-irled.c
@@ -185,7 +185,12 @@ static ssize_t clock_store(struct device *dev, struct device_attribute *attr,
 	unsigned int _data;
 	if (sscanf(buf, "%u", &_data) == 1)
 		if (_data == 300000 || _data == 600000 || _data == 800000
-		    || _data == 1008000)
+		    || _data == 1008000
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+		    || _data == 1200000 || _data == 1350000
+		    || _data == 1420000|| _data == 1480000 /* || _data == 1520000 */
+#endif
+		   )
 			ir_data.cpu_frequency = _data;
 
 	return size;
diff --git a/arch/arm/mach-omap2/board-espresso10-irled.c b/arch/arm/mach-omap2/board-espresso10-irled.c
index 2eb31ad..1906303 100644
--- a/arch/arm/mach-omap2/board-espresso10-irled.c
+++ b/arch/arm/mach-omap2/board-espresso10-irled.c
@@ -185,7 +185,12 @@ static ssize_t clock_store(struct device *dev, struct device_attribute *attr,
 	unsigned int _data;
 	if (sscanf(buf, "%u", &_data) == 1)
 		if (_data == 300000 || _data == 600000 || _data == 800000
-		    || _data == 1008000)
+		    || _data == 1008000
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+		    || _data == 1200000 || _data == 1350000
+		    || _data == 1420000|| _data == 1480000 /* || _data == 1520000 */
+#endif
+		   )
 			ir_data.cpu_frequency = _data;
 
 	return size;
diff --git a/arch/arm/mach-omap2/control.h b/arch/arm/mach-omap2/control.h
index f688010..29647ec 100644
--- a/arch/arm/mach-omap2/control.h
+++ b/arch/arm/mach-omap2/control.h
@@ -195,6 +195,7 @@
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPTURBO	0x246
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO	0x249
 #define OMAP44XX_CONTROL_FUSE_MPU_OPPNITROSB	0x24C
+#define OMAP44XX_CONTROL_FUSE_MPU_OPPSUPERSB	0x24F
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP50	0x254
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP100	0x257
 #define OMAP44XX_CONTROL_FUSE_CORE_OPP100OV	0x25A
diff --git a/arch/arm/mach-omap2/dpll44xx.c b/arch/arm/mach-omap2/dpll44xx.c
index 620de77..e6f88b8 100644
--- a/arch/arm/mach-omap2/dpll44xx.c
+++ b/arch/arm/mach-omap2/dpll44xx.c
@@ -231,6 +231,7 @@ int omap4_prcm_freq_update(void)
 /* Use a very high retry count - we should not hit this condition */
 #define MAX_DPLL_WAIT_TRIES	1000000
 
+#define OMAP_1_9GHz	1900000000
 #define OMAP_1_5GHz	1500000000
 #define OMAP_1_2GHz	1200000000
 #define OMAP_1GHz	1000000000
diff --git a/arch/arm/mach-omap2/omap2plus-cpufreq.c b/arch/arm/mach-omap2/omap2plus-cpufreq.c
index 99d508c..5281614 100644
--- a/arch/arm/mach-omap2/omap2plus-cpufreq.c
+++ b/arch/arm/mach-omap2/omap2plus-cpufreq.c
@@ -336,6 +336,9 @@ void omap_cpufreq_max_limit_free(unsigned int nId)
 }
 #endif
 
+#ifdef CONFIG_OMAP4430_GPU_OVERCLOCK
+static int gpu_freq_idx;
+#endif
 
 static unsigned int omap_getspeed(unsigned int cpu)
 {
@@ -856,9 +859,71 @@ struct freq_attr omap_cpufreq_attr_screen_off_freq = {
 	.store = store_screen_off_freq,
 };
 
+#ifdef CONFIG_OMAP4430_GPU_OVERCLOCK
+/*
+ * Variable GPU OC - sysfs interface for cycling through different GPU top speeds
+ * Author: imoseyon@gmail.com
+ *
+*/
+static ssize_t show_gpu_freq_idx(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%d\n", gpu_freq_idx);
+}
+
+static ssize_t store_gpu_freq_idx(struct cpufreq_policy *policy, const char *buf, size_t size)
+{
+	int prev_idx, ret1, ret2; 
+        struct device *dev;
+	unsigned long gpu_freqs[3] = {307200000,384000000,512000000};
+
+	prev_idx = gpu_freq_idx;
+	if (prev_idx < 0 || prev_idx > 2) {
+		// shouldn't be here
+		pr_info("[imoseyon] gpu_oc error - bailing\n");	
+		return size;
+	}
+
+	sscanf(buf, "%d\n", &gpu_freq_idx);
+	if (gpu_freq_idx < 0)
+		gpu_freq_idx = 0;
+	if (gpu_freq_idx > 2)
+		gpu_freq_idx = 2;
+	if (prev_idx == gpu_freq_idx)
+		return size;
+
+        dev = omap_hwmod_name_get_dev("gpu");
+	ret1 = opp_disable(dev, gpu_freqs[prev_idx]);
+        ret2 = opp_enable(dev, gpu_freqs[gpu_freq_idx]);
+        pr_info("[imoseyon] gpu top speed changed from %lu to %lu (%d,%d)\n", 
+		gpu_freqs[prev_idx], gpu_freqs[gpu_freq_idx], ret1, ret2);
+	
+	return size;
+}
+
+static struct freq_attr omap_cpufreq_attr_gpu_freq_idx = {
+	.attr = { .name = "gpu_max_freq_idx",
+		  .mode = 0644,
+		},
+	.show = show_gpu_freq_idx,
+	.store = store_gpu_freq_idx,
+};
+
+static struct freq_attr omap_cpufreq_attr_gpu_oc = {
+	.attr = { .name = "gpu_oc",
+		  .mode = 0644,
+		},
+	.show = show_gpu_freq_idx,
+	.store = store_gpu_freq_idx,
+};
+#endif
+
 static struct freq_attr *omap_cpufreq_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
 	&omap_cpufreq_attr_screen_off_freq,
+#ifdef CONFIG_OMAP4430_GPU_OVERCLOCK
+	&omap_cpufreq_attr_gpu_freq_idx,
+	&omap_cpufreq_attr_gpu_oc,
+#endif
 	NULL,
 };
 
@@ -912,6 +977,10 @@ static int __init omap_cpufreq_init(void)
 {
 	int ret;
 
+#ifdef CONFIG_OMAP4430_GPU_OVERCLOCK
+	gpu_freq_idx = 1;
+#endif
+
 	if (cpu_is_omap24xx())
 		mpu_clk_name = "virt_prcm_set";
 	else if (cpu_is_omap34xx())
diff --git a/arch/arm/mach-omap2/omap4_trim_quirks.c b/arch/arm/mach-omap2/omap4_trim_quirks.c
index 8ee3df6..581e9ef 100644
--- a/arch/arm/mach-omap2/omap4_trim_quirks.c
+++ b/arch/arm/mach-omap2/omap4_trim_quirks.c
@@ -30,7 +30,11 @@
 #define OMAP4_PROD_ID_I684_MASK		0x000C0000
 
 static bool bgap_trim_sw_overide;
+#if defined(CONFIG_OMAP4430_CPU_OVERCLOCK) || defined(CONFIG_OMAP4430_GPU_OVERCLOCK)
+static bool dpll_trim_override = true;
+#else
 static bool dpll_trim_override;
+#endif
 static bool ddr_io_trim_override;
 
 /**
@@ -79,7 +83,11 @@ int omap4_ldo_trim_configure(void)
 
 	/* Required for DPLL_MPU to lock at 2.4 GHz */
 	if (dpll_trim_override)
+#if defined(CONFIG_OMAP4430_CPU_OVERCLOCK) || defined(CONFIG_OMAP4430_GPU_OVERCLOCK)
+		omap_ctrl_writel(0x2b, OMAP4_CTRL_MODULE_CORE_DPLL_NWELL_TRIM_0);
+#else
 		omap_ctrl_writel(0x29, OMAP4_CTRL_MODULE_CORE_DPLL_NWELL_TRIM_0);
+#endif
 
 	return 0;
 }
diff --git a/arch/arm/mach-omap2/opp4xxx_data.c b/arch/arm/mach-omap2/opp4xxx_data.c
index 17b8e5a..2a9008f 100644
--- a/arch/arm/mach-omap2/opp4xxx_data.c
+++ b/arch/arm/mach-omap2/opp4xxx_data.c
@@ -98,7 +98,15 @@ struct omap4_ldo_abb_trim_data {
 #define OMAP4430_VDD_MPU_OPP100_UV		1200000
 #define OMAP4430_VDD_MPU_OPPTURBO_UV		1313000
 #define OMAP4430_VDD_MPU_OPPNITRO_UV		1374000
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+#define OMAP4430_VDD_MPU_OPPNITRO2_UV		1375000
+#define OMAP4430_VDD_MPU_OPPNITROSB_UV		1385000
+#define OMAP4430_VDD_MPU_OPPNITROSB2_UV		1395000
+#define OMAP4430_VDD_MPU_OPPSUPERSB_UV		1405000
+#define OMAP4430_VDD_MPU_OPPSUPERSB2_UV		1415000
+#else
 #define OMAP4430_VDD_MPU_OPPNITROSB_UV		1375000
+#endif
 
 struct omap_volt_data omap443x_vdd_mpu_volt_data[] = {
 	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPP50_UV, 0,
@@ -113,9 +121,27 @@ struct omap_volt_data omap443x_vdd_mpu_volt_data[] = {
 	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITRO_UV, 0,
 			OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO,
 			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITRO2_UV, 0,
+			OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO,
+			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITROSB_UV, 0,
+			OMAP44XX_CONTROL_FUSE_MPU_OPPNITROSB,
+			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITROSB2_UV, 0,
+			OMAP44XX_CONTROL_FUSE_MPU_OPPNITROSB,
+			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPSUPERSB_UV, 0,
+			OMAP44XX_CONTROL_FUSE_MPU_OPPSUPERSB,
+			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPSUPERSB2_UV, 0,
+			OMAP44XX_CONTROL_FUSE_MPU_OPPSUPERSB,
+			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+#else
 	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITROSB_UV, 0,
 			OMAP44XX_CONTROL_FUSE_MPU_OPPNITROSB,
 			0xfa, 0x27, OMAP_ABB_FAST_OPP),
+#endif
 	VOLT_DATA_DEFINE(0, 0, 0, 0, 0, 0),
 };
 
@@ -138,6 +164,9 @@ struct omap_volt_data omap443x_vdd_iva_volt_data[] = {
 
 #define OMAP4430_VDD_CORE_OPP50_UV		1025000
 #define OMAP4430_VDD_CORE_OPP100_UV		1200000
+#if defined(CONFIG_OMAP4430_CPU_OVERCLOCK) || defined(CONFIG_OMAP4430_GPU_OVERCLOCK)
+#define OMAP4430_VDD_CORE_OPP100_OV_UV		1250000
+#endif
 
 struct omap_volt_data omap443x_vdd_core_volt_data[] = {
 	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP50_UV, 0,
@@ -146,6 +175,11 @@ struct omap_volt_data omap443x_vdd_core_volt_data[] = {
 	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP100_UV, 0,
 			OMAP44XX_CONTROL_FUSE_CORE_OPP100,
 			0xf9, 0x16, OMAP_ABB_NONE),
+#if defined(CONFIG_OMAP4430_CPU_OVERCLOCK) || defined(CONFIG_OMAP4430_GPU_OVERCLOCK)
+	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP100_OV_UV, 0,
+			OMAP44XX_CONTROL_FUSE_CORE_OPP100OV,
+			0xf9, 0x16, OMAP_ABB_NONE),
+#endif
 	VOLT_DATA_DEFINE(0, 0, 0, 0, 0, 0),
 };
 
@@ -168,8 +202,21 @@ static struct omap_vdd_dep_volt omap443x_vdd_mpu_core_dep_data[] = {
 			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
 	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPNITRO_UV,
 			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPNITRO2_UV,
+			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
 	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPNITROSB_UV,
 			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
+	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPNITROSB2_UV,
+			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
+	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPSUPERSB_UV,
+			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_OV_UV},
+	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPSUPERSB2_UV,
+			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_OV_UV},
+#else
+	{.main_vdd_volt = OMAP4430_VDD_MPU_OPPNITROSB_UV,
+			.dep_vdd_volt = OMAP4430_VDD_CORE_OPP100_UV},
+#endif
 };
 
 struct omap_vdd_dep_info omap443x_vddmpu_dep_info[] = {
@@ -213,9 +260,27 @@ static struct omap_opp_def __initdata omap443x_opp_def_list[] = {
 	/* MPU OPP4 - OPP-SB */
 	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", true,
 			1008000000, OMAP4430_VDD_MPU_OPPNITRO_UV),
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+	/* MPU OPP4 - OPP-NITRO2 */
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
+			1200000000, OMAP4430_VDD_MPU_OPPNITRO2_UV),
+	/* MPU OPP5 - OPP-NITROSB */
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
+			1350000000, OMAP4430_VDD_MPU_OPPNITROSB_UV),
+	/* MPU OPP6 - OPP-NITROSB2 */
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
+			1420000000, OMAP4430_VDD_MPU_OPPNITROSB2_UV),
+	/* MPU OPP7 - OPP-SUPERSB */
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
+			1480000000, OMAP4430_VDD_MPU_OPPSUPERSB_UV),
+	/* MPU OPP8 - OPP-SUPERSB2 */
+	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
+			1520000000, OMAP4430_VDD_MPU_OPPSUPERSB2_UV),
+#else
 	/* MPU OPP4 - OPP-NITROSB */
 	OPP_INITIALIZER("mpu", "dpll_mpu_ck", "mpu", false,
 			1200000000, OMAP4430_VDD_MPU_OPPNITROSB_UV),
+#endif
 	/* L3 OPP1 - OPP50 */
 	OPP_INITIALIZER("l3_main_1", "virt_l3_ck", "core", true,
 			100000000, OMAP4430_VDD_CORE_OPP50_UV),
@@ -237,6 +302,12 @@ static struct omap_opp_def __initdata omap443x_opp_def_list[] = {
 	/* SGX OPP2 - OPP100 */
 	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", true,
 			307200000, OMAP4430_VDD_CORE_OPP100_UV),
+#ifdef CONFIG_OMAP4430_GPU_OVERCLOCK
+	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", true,
+			384000000, OMAP4430_VDD_CORE_OPP100_UV),
+	OPP_INITIALIZER("gpu", "dpll_per_m7x2_ck", "core", false,
+			512000000, OMAP4430_VDD_CORE_OPP100_OV_UV),
+#endif
 	/* FDIF OPP1 - OPP25 */
 	OPP_INITIALIZER("fdif", "fdif_fck", "core", true,
 			32000000, OMAP4430_VDD_CORE_OPP50_UV),
@@ -971,6 +1042,15 @@ int __init omap4_opp_init(void)
 
 	if (r)
 		goto out;
+#ifdef CONFIG_OMAP4430_CPU_OVERCLOCK
+	else {
+		omap4_opp_enable("mpu", 1200000000);
+		omap4_opp_enable("mpu", 1350000000);
+		omap4_opp_enable("mpu", 1420000000);
+		omap4_opp_enable("mpu", 1480000000);
+		/* omap4_opp_enable("mpu", 1520000000); */
+	}
+#endif
 
 	/* Enable Nitro and NitroSB IVA OPPs */
 	if (omap4_has_iva_430mhz())
diff --git a/arch/arm/mach-omap2/smartreflex-class3.c b/arch/arm/mach-omap2/smartreflex-class3.c
index ebff9a4..1fd459d 100644
--- a/arch/arm/mach-omap2/smartreflex-class3.c
+++ b/arch/arm/mach-omap2/smartreflex-class3.c
@@ -54,7 +54,11 @@ static struct omap_sr_class_data class3_data = {
 static int __init sr_class3_init(void)
 {
 	/* Enable this class only for OMAP343x and OMAP443x */
+#if defined(CONFIG_OMAP4430_CPU_OVERCLOCK) || defined(CONFIG_OMAP4430_GPU_OVERCLOCK)
+	if (!cpu_is_omap343x())
+#else
 	if (!cpu_is_omap343x() && !cpu_is_omap443x())
+#endif
 		return -EINVAL;
 
 	pr_info("SmartReflex Class3 initialized\n");
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 0a5bea9..8c261a0 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -32,6 +32,9 @@
 
 #include <trace/events/power.h>
 
+/* Safe boot speed */
+#define SafeBootSpeed 1008000
+
 /**
  * The "cpufreq driver" - the arch- or hardware-dependent low
  * level driver of CPUFreq support, and its spinlock. This lock
@@ -941,6 +944,9 @@ static int cpufreq_add_dev(struct sys_device *sys_dev)
 		pr_debug("initialization failed\n");
 		goto err_unlock_policy;
 	}
+
+	/* Set max speed at boot to 1.008Ghz since is the safest speed to boot */
+	if (policy->max > SafeBootSpeed) policy->max = SafeBootSpeed;
 	policy->user_policy.min = policy->min;
 	policy->user_policy.max = policy->max;
 
